/****************************************************************************
** Copyright (c) 2013-2023 Mazatech S.r.l.
** All rights reserved.
**
** This file is part of AmanithSVG software, an SVG rendering library.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted (subject to the limitations in the disclaimer
** below) provided that the following conditions are met:
**
** - Redistributions of source code must retain the above copyright notice,
**   this list of conditions and the following disclaimer.
**
** - Redistributions in binary form must reproduce the above copyright notice,
**   this list of conditions and the following disclaimer in the documentation
**   and/or other materials provided with the distribution.
**
** - Neither the name of Mazatech S.r.l. nor the names of its contributors
**   may be used to endorse or promote products derived from this software
**   without specific prior written permission.
**
** NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED
** BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
** CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
** NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
** OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
** EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
** PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
** OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
** OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
** ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
** For any information, please contact info@mazatech.com
**
****************************************************************************/

/*!
    \file png_utils.c
    \brief PNG utilities, implementation.
    \author Matteo Muratori
    \author Michele Fabbri
*/

#include <string.h>
/* disable unused features, here we need miniz just to write PNG files */
#define MINIZ_NO_STDIO
#define MINIZ_NO_ARCHIVE_APIS
#define MINIZ_NO_TIME
#define MINIZ_NO_ZLIB_APIS
#include "miniz.c"
#include "png_utils.h"

// swap R and B components (ARGB <--> ABGR and vice versa)
static SVGTuint redBlueSwap(SVGTuint p) {

    // swap R <--> B
    SVGTuint ag = p & 0xFF00FF00U;
    SVGTuint rb = p & 0x00FF00FFU;
    SVGTuint r = rb >> 16;
    SVGTuint b = rb & 0xFFU;
    return ag | (b << 16) | r;
}

// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
static SVGTuint crc32Miniz(const SVGTubyte* buffer,
                           size_t bufferLen) {

    static const SVGTuint crc32Table[16] = {
        0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
    };

    SVGTuint crcu32 = ~(0U);

    while (bufferLen--) {
        SVGTubyte b = *buffer++;
        crcu32 = (crcu32 >> 4) ^ crc32Table[(crcu32 & 0x0FU) ^ (b & 0x0FU)];
        crcu32 = (crcu32 >> 4) ^ crc32Table[(crcu32 & 0x0FU) ^ (b >> 4)];
    }
    return ~crcu32;
}

// this is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck
static void* pngWriteMiniz(size_t* outSize,
                           const SVGTubyte* pixels,
                           const SVGTuint width,
                           const SVGTuint height,
                           const PixelFormat pixelFormat,
                           const SVGTuint compressionLevel,
                           const SVGTboolean verticalFlip,
                           const char* description,
                           const char* comment) {

    #define NUM_CHANNELS 4

    void* result = NULL;
    static const SVGTubyte pngColorChans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
    static const SVGTuint pngProbes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
    // the deflate encoder (miniz)
    tdefl_compressor* minizCompressor = (tdefl_compressor*)calloc(1, sizeof(tdefl_compressor));

    if (minizCompressor != NULL) {
        // PNG header
        SVGTubyte pngHeader[] = {
            // standard PNG header
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            // ---------------------------------------------------------------------------
            // IHDR chunk (length)
            0x00, 0x00, 0x00, 0x0D,
            // "IHDR" (chunk type)
            0x49, 0x48, 0x44, 0x52,
            // image width
            0, 0, (SVGTubyte)(width >> 8), (SVGTubyte)width,
            // image height
            0, 0, (SVGTubyte)(height >> 8), (SVGTubyte)height,
            // bit depth
            8,
            // color type
            pngColorChans[NUM_CHANNELS],
            // compression method
            0,
            // filter method
            0,
            // interlace method
            0,
            // CRC (CRC is computed over the chunk type and chunk data, but not the length)
            // just dummy values for the moment, will be calculate later
            0, 0, 0, 0,
            // ---------------------------------------------------------------------------
            //
            // IDAT chunk (length)
            // just dummy values for the moment, will be calculate later
            0, 0, 0, 0,
            // "IDAT" (chunk type)
            0x49, 0x44, 0x41, 0x54
        };
        const SVGTuint pngHeaderSize = sizeof(pngHeader) / sizeof(SVGTubyte);
        // PNG footer
        const SVGTuint descriptionLen = description ? (SVGTuint)strlen(description) : 0;
        const SVGTuint commentLen = comment ? (SVGTuint)strlen(comment) : 0;
        const SVGTuint textDescriptionChunkLen = 11 + 1 + descriptionLen;
        const SVGTuint textCommentChunkLen = 7 + 1 + commentLen;
        // IDAT CRC, description (tEXt chunk), comment (tEXt chunk), IEND chunk
        const SVGTuint pngFooterSize = 4 + (8 + textDescriptionChunkLen + 4) + (8 + textCommentChunkLen + 4) + (8 + 4);
        SVGTubyte* pngFooter = (SVGTubyte*)calloc(pngFooterSize, sizeof(SVGTubyte));

        if (pngFooter != NULL) {

            tdefl_output_buffer outBuffer;
            const SVGTuint bpl = width * NUM_CHANNELS;
    
            // initialize output buffer
            outBuffer.m_size = 0U;
            outBuffer.m_pBuf = NULL;
            outBuffer.m_expandable = MZ_TRUE;
            outBuffer.m_capacity = (pngHeaderSize + pngFooterSize) + MAX(64U, (1U + bpl) * height);
            if ((outBuffer.m_pBuf = (SVGTubyte*)malloc(outBuffer.m_capacity * sizeof(SVGTubyte))) != NULL) {

                SVGTuint y, z;
                const SVGTint pitch = (verticalFlip ? (-(SVGTint)width) : (SVGTint)width);
                SVGTuint *p = (SVGTuint*)(verticalFlip ? &pixels[(height - 1) * bpl] : pixels);

                // write dummy header
                for (z = pngHeaderSize; z != 0U; --z) {
                    tdefl_output_buffer_putter(&z, 1, &outBuffer);
                }

                // initialize deflate encoding
                tdefl_init(minizCompressor, tdefl_output_buffer_putter, &outBuffer, pngProbes[MIN(10U, compressionLevel)] | TDEFL_WRITE_ZLIB_HEADER);
                // loop over scanlines
                for (y = height; y != 0; --y) {
                    // filter type (0 = no filter)
                    tdefl_compress_buffer(minizCompressor, &z, 1U, TDEFL_NO_FLUSH);
                    // swap red and blue values
                    if (pixelFormat == FORMAT_RGBA) {
                        SVGTuint x, * scanline = p;
                        for (x = width; x != 0; --x) {
                            const SVGTuint argb = *scanline;
                            *scanline++ = redBlueSwap(argb);
                        }
                    }
                    // encode a scanline
                    tdefl_compress_buffer(minizCompressor, p, bpl, TDEFL_NO_FLUSH);
                    // next scanline
                    p += pitch;
                }

                // close the deflate encoding
                if (tdefl_compress_buffer(minizCompressor, NULL, 0U, TDEFL_FINISH) == TDEFL_STATUS_DONE) {

                    SVGTuint i;
                    size_t j;
                    SVGTubyte* textChunkTypePtr;
                    const SVGTuint compressedDataSize = (SVGTuint)outBuffer.m_size - pngHeaderSize;

                    // calculate CRC for IHDR chunk (CRC is computed over the chunk type and chunk data, but not the length)
                    SVGTuint crc = crc32Miniz(&pngHeader[12], 17);
                    for (i = 0; i < 4; ++i, crc <<= 8) {
                        pngHeader[29 + i] = (SVGTubyte)((crc >> 24) & 0xFF);
                    }
                    // write IDAT chunk length
                    pngHeader[33] = (SVGTubyte)(compressedDataSize >> 24);
                    pngHeader[34] = (SVGTubyte)((compressedDataSize >> 16) & 0xFF);
                    pngHeader[35] = (SVGTubyte)((compressedDataSize >> 8) & 0xFF);
                    pngHeader[36] = (SVGTubyte)(compressedDataSize & 0xFF);
                    // write real header
                    (void)memcpy(outBuffer.m_pBuf, pngHeader, pngHeaderSize);

                    j = 0;
                    // calculate CRC for IDAT chunk (CRC is computed over the chunk type and chunk data, but not the length)
                    crc = crc32Miniz(&outBuffer.m_pBuf[pngHeaderSize - 4], 4 + compressedDataSize);
                    for (i = 0; i < 4; ++i, crc <<= 8) {
                        pngFooter[j++] = (SVGTubyte)((crc >> 24) & 0xFF);
                    }
            
                    // tEXt chunk (length)
                    pngFooter[j++] = (SVGTubyte)(textDescriptionChunkLen >> 24);
                    pngFooter[j++] = (SVGTubyte)((textDescriptionChunkLen >> 16) & 0xFF);
                    pngFooter[j++] = (SVGTubyte)((textDescriptionChunkLen >> 8) & 0xFF);
                    pngFooter[j++] = (SVGTubyte)(textDescriptionChunkLen & 0xFF);
                    // "tEXt"
                    textChunkTypePtr = &pngFooter[j];
                    pngFooter[j++] = 't';
                    pngFooter[j++] = 'E';
                    pngFooter[j++] = 'X';
                    pngFooter[j++] = 't';
                    // tEXt chunk data: keyword + null separaror + text characters
                    (void)strcpy((char*)& pngFooter[j], "Description");
                    j += strlen("Description");
                    pngFooter[j++] = 0;
                    for (i = 0; i < descriptionLen; ++i) {
                        pngFooter[j++] = description[i];
                    }
                    // tEXt chunk CRC (CRC is computed over the chunk type and chunk data, but not the length)
                    crc = crc32Miniz(textChunkTypePtr, 4 + textDescriptionChunkLen);
                    for (i = 0; i < 4; ++i, crc <<= 8) {
                        pngFooter[j++] = (SVGTubyte)((crc >> 24) & 0xFF);
                    }

                    // tEXt chunk (length)
                    pngFooter[j++] = (SVGTubyte)(textCommentChunkLen >> 24);
                    pngFooter[j++] = (SVGTubyte)((textCommentChunkLen >> 16) & 0xFF);
                    pngFooter[j++] = (SVGTubyte)((textCommentChunkLen >> 8) & 0xFF);
                    pngFooter[j++] = (SVGTubyte)(textCommentChunkLen & 0xFF);
                    // "tEXt"
                    textChunkTypePtr = &pngFooter[j];
                    pngFooter[j++] = 't';
                    pngFooter[j++] = 'E';
                    pngFooter[j++] = 'X';
                    pngFooter[j++] = 't';
                    // tEXt chunk data: keyword + null separaror + text characters
                    (void)strcpy((char*) & pngFooter[j], "Comment");
                    j += strlen("Comment");
                    pngFooter[j++] = 0;
                    for (i = 0; i < commentLen; ++i) {
                        pngFooter[j++] = comment[i];
                    }
                    // tEXt chunk CRC (CRC is computed over the chunk type and chunk data, but not the length)
                    crc = crc32Miniz(textChunkTypePtr, 4 + textCommentChunkLen);
                    for (i = 0; i < 4; ++i, crc <<= 8) {
                        pngFooter[j++] = (SVGTubyte)((crc >> 24) & 0xFF);
                    }

                    // IEND chunk (length)
                    pngFooter[j++] = 0;
                    pngFooter[j++] = 0;
                    pngFooter[j++] = 0;
                    pngFooter[j++] = 0;
                    // "IEND"
                    pngFooter[j++] = 'I';
                    pngFooter[j++] = 'E';
                    pngFooter[j++] = 'N';
                    pngFooter[j++] = 'D';
                    // data is empty for IEND chunk!
                    // IEND chunk (CRC)
                    pngFooter[j++] = 0xAE;
                    pngFooter[j++] = 0x42;
                    pngFooter[j++] = 0x60;
                    pngFooter[j++] = 0x82;

                    // write footer
                    if (!tdefl_output_buffer_putter(pngFooter, pngFooterSize, &outBuffer)) {
                        free(outBuffer.m_pBuf);
                    }
                    else {
                        // compute final size of file
                        *outSize = pngHeaderSize + compressedDataSize + pngFooterSize;
                        result = outBuffer.m_pBuf;
                    }
                }
                else {
                    free(outBuffer.m_pBuf);
                }
            }
            free(pngFooter);
        }
        free(minizCompressor);
    }

    return result;
}

/************************************************************
                       PNG encoder
************************************************************/
void* pngEncode(size_t* pngDataSize,
                const SVGTubyte* pixels,
                const SVGTuint width,
                const SVGTuint height,
                const SVGTuint compressionLevel,
                const PixelFormat pixelFormat,
                const char* description,
                const char* comment) {

    // encode drawing surface pixels in PNG format (in-memory encoding)
    void* pngData = pngWriteMiniz(pngDataSize,
                                  pixels, width, height,
                                  pixelFormat,
                                  // compression level (0..10)
                                  compressionLevel,
                                  // vertical flip
                                  SVGT_TRUE,
                                  // optional description (text)
                                  description,
                                  // optional comment (text)
                                  comment);

    return pngData;
}

void pngDestroy(void* pngData) {

    if (pngData != NULL) {
        // free allocated memory
        mz_free(pngData);
    }
}
