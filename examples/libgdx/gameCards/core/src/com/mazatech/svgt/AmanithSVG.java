/****************************************************************************
** Copyright (c) 2013-2023 Mazatech S.r.l.
** All rights reserved.
** 
** This file is part of AmanithSVG software, an SVG rendering library.
** 
** Redistribution and use in source and binary forms, with or without
** modification, are permitted (subject to the limitations in the disclaimer
** below) provided that the following conditions are met:
** 
** - Redistributions of source code must retain the above copyright notice,
**   this list of conditions and the following disclaimer.
** 
** - Redistributions in binary form must reproduce the above copyright notice,
**   this list of conditions and the following disclaimer in the documentation
**   and/or other materials provided with the distribution.
** 
** - Neither the name of Mazatech S.r.l. nor the names of its contributors
**   may be used to endorse or promote products derived from this software
**   without specific prior written permission.
** 
** NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED
** BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
** CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
** NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
** OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
** EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
** PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
** OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
** OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
** ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** 
** For any information, please contact info@mazatech.com
** 
****************************************************************************/

package com.mazatech.svgt;

import java.util.EnumSet;

public class AmanithSVG {

    /*-------------------------------------------------------------------------------
                            Utility for common error checking
    -------------------------------------------------------------------------------*/
    private static void checkArrayLength(int count, final int[] values, int offset) {

        if (values == null) {
            throw new IllegalArgumentException("values == null");
        }

        if (offset < 0) {
            throw new IllegalArgumentException("offset < 0");
        }

        if (values.length - offset < count) {
            throw new IllegalArgumentException("not enough remaining entries (values)");
        }
    }

    private static void checkArrayLength(int count, final float[] values, int offset) {

        if (values == null) {
            throw new IllegalArgumentException("values == null");
        }

        if (offset < 0) {
            throw new IllegalArgumentException("offset < 0");
        }

        if (values.length - offset < count) {
            throw new IllegalArgumentException("not enough remaining entries (values)");
        }
    }

    private static int boolToInt(boolean b) {

        return (b ? AmanithSVGJNI.SVGT_TRUE : AmanithSVGJNI.SVGT_FALSE);
    }

    /*-------------------------------------------------------------------------------
                                 API implementation
    -------------------------------------------------------------------------------*/
    // Retrieve the error code generated by the last called API function.
    public static SVGTError svgtGetLastError() {

        return SVGTError.fromValue(AmanithSVGJNI.svgtGetLastError());
    }

    // Initialize the library.
    public static SVGTError svgtInit(int screenWidth, int screenHeight, float dpi) {

        // native svgtInit takes unsigned integers as dimensions, JNI wrapper simply casts them
        // to unsigned integer so here we have to "protect" the native cast operation
        if (screenWidth <= 0) {
            throw new IllegalArgumentException("screenWidth <= 0");
        }
        if (screenHeight <= 0) {
            throw new IllegalArgumentException("screenHeight <= 0");
        }
        if (dpi <= 0) {
            throw new IllegalArgumentException("dpi < 0");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtInit(screenWidth, screenHeight, dpi));
    }

    // Destroy the library, freeing all allocated resources.
    public static void svgtDone() {

        AmanithSVGJNI.svgtDone();
    }

    // Configure parameters and thresholds for the AmanithSVG library.
    public static SVGTError svgtConfigSet(SVGTConfig config, float value) {

        // check arguments
        if (config == null) {
            throw new IllegalArgumentException("config == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtConfigSet(config.getValue(), value));
    }

    // Get the current value relative to the specified configuration parameter.
    public static float svgtConfigGet(SVGTConfig config) {

        // check arguments
        if (config == null) {
            throw new IllegalArgumentException("config == null");
        }

        return AmanithSVGJNI.svgtConfigGet(config.getValue());
    }

    // Set the system / user-agent language.
    public static SVGTError svgtLanguageSet(final String languages) {

        return SVGTError.fromValue(AmanithSVGJNI.svgtLanguageSet(languages));
    }

    // Instruct the library about an external resource.
    public static SVGTError svgtResourceSet(final String id, final java.nio.ByteBuffer buffer, SVGTResourceType type, final EnumSet<SVGTResourceHint> hints) {

        // check arguments
        if (buffer == null) {
            throw new IllegalArgumentException("buffer == null");
        }
        if (!buffer.isDirect()) {
            // NB: the given buffer must be direct, because we want to be sure that its address won't change
            // Direct buffers have this peculiarity: once allocated, their memory address is fixed for
            // the lifetime of the buffer.
            throw new IllegalArgumentException("buffer is not 'direct'");
        }
        if (buffer.capacity() <= 0) {
            throw new IllegalArgumentException("buffer.capacity <= 0");
        }

        // 'buffer' must point to a read-only area containing the resource file.
        // Such read-only buffer must be a valid and immutable memory area throughout the whole life
        // of the application that uses the library. In multi-thread applications the 'buffer' memory
        // must be accessible (readable) by all threads.
        return SVGTError.fromValue(AmanithSVGJNI.svgtResourceSet(id, buffer, type.getValue(), SVGTResourceHint.getBitfield(hints)));
    }

    // Get the maximum number of different threads that can "work" (e.g. create surfaces, create documents and draw them) concurrently.
    public static int svgtMaxCurrentThreads() {

        return AmanithSVGJNI.svgtMaxCurrentThreads();
    }

    // Get the maximum dimension allowed for drawing surfaces.
    public static int svgtSurfaceMaxDimension() {

        return AmanithSVGJNI.svgtSurfaceMaxDimension();
    }

    // Set the log buffer for the current thread.
    public static SVGTError svgtLogBufferSet(java.nio.ByteBuffer logBuffer, final EnumSet<SVGTLogLevel> logLevel) {

        // check arguments
        if (logBuffer != null) {
            if (!logBuffer.isDirect()) {
                // NB: the given buffer must be direct, because we want to be sure that its address won't change
                // Direct buffers have this peculiarity: once allocated, their memory address is fixed for
                // the lifetime of the buffer.
                throw new IllegalArgumentException("logBuffer is not 'direct'");
            }
            if (logBuffer.capacity() <= 0) {
                throw new IllegalArgumentException("logBuffer.capacity <= 0");
            }
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtLogBufferSet(logBuffer, SVGTLogLevel.getBitfield(logLevel)));
    }

    // Append the given message to the log buffer.
    public static SVGTError svgtLogPrint(final String message, SVGTLogLevel level) {

        // check arguments
        if (message == null) {
            throw new IllegalArgumentException("message == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtLogPrint(message, level.getValue()));
    }

    // Get information about the current thread log buffer.
    public static SVGTError svgtLogBufferInfo(int[] info, int offset) {

        checkArrayLength(4, info, offset);

        return SVGTError.fromValue(AmanithSVGJNI.svgtLogBufferInfo(info, offset));
    }

    public static SVGTError svgtLogBufferInfo(int[] info) {

        return svgtLogBufferInfo(info, 0);
    }

    // Create a new drawing surface, specifying its dimensions in pixels.
    public static SVGTHandle svgtSurfaceCreate(int width, int height) {

        int handle;

        // native svgtSurfaceCreate takes unsigned integers as dimensions, JNI wrapper simply casts
        // them to unsigned integer so here we have to "protect" the native cast operation
        if (width < 0) {
            throw new IllegalArgumentException("width < 0");
        }
        if (height < 0) {
            throw new IllegalArgumentException("height < 0");
        }

        handle = AmanithSVGJNI.svgtSurfaceCreate(width, height);
        return (handle == AmanithSVGJNI.SVGT_INVALID_HANDLE) ? null : new SVGTHandle(handle);
    }

    // Destroy a previously created drawing surface.
    public static SVGTError svgtSurfaceDestroy(SVGTHandle surface) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceDestroy(surface.getNativeHandle()));
    }

    // Resize a drawing surface, specifying new dimensions in pixels.
    public static SVGTError svgtSurfaceResize(SVGTHandle surface, int newWidth, int newHeight) {

        // native svgtSurfaceResize takes unsigned integers as dimensions, JNI wrapper simply
        // casts them to unsigned integer so here we have to "protect" the native cast operation
        if (newWidth < 0) {
            throw new IllegalArgumentException("newWidth < 0");
        }
        if (newHeight < 0) {
            throw new IllegalArgumentException("newHeight < 0");
        }
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceResize(surface.getNativeHandle(), newWidth, newHeight));
    }

    // Get width dimension (in pixels), of the specified drawing surface.
    public static int svgtSurfaceWidth(SVGTHandle surface) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return AmanithSVGJNI.svgtSurfaceWidth(surface.getNativeHandle());
    }

    // Get height dimension (in pixels), of the specified drawing surface.
    public static int svgtSurfaceHeight(SVGTHandle surface) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return AmanithSVGJNI.svgtSurfaceHeight(surface.getNativeHandle());
    }

    // Get access to the drawing surface pixels.
    public static java.nio.ByteBuffer svgtSurfacePixels(SVGTHandle surface) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        // NB: the returned buffer is a direct buffer referring to the surface pixels memory
        return AmanithSVGJNI.svgtSurfacePixels(surface.getNativeHandle());
    }

    // Copy drawing surface content into the specified pixels array.
    public static SVGTError svgtSurfaceCopy(SVGTHandle surface, int[] dstPixels32, int offset, boolean redBlueSwap, boolean dilateEdgesFix) {

        int srfWidth, srfHeight, err;

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        // get surface dimensions
        srfWidth = AmanithSVGJNI.svgtSurfaceWidth(surface.getNativeHandle());
        srfHeight = AmanithSVGJNI.svgtSurfaceHeight(surface.getNativeHandle());
        checkArrayLength(srfWidth * srfHeight, dstPixels32, offset);
        // perform the real copy
        return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceCopyA(surface.getNativeHandle(), dstPixels32, offset, boolToInt(redBlueSwap), boolToInt(dilateEdgesFix)));
    }

    public static SVGTError svgtSurfaceCopy(SVGTHandle surface, int[] dstPixels32, boolean redBlueSwap, boolean dilateEdgesFix) {

        return svgtSurfaceCopy(surface, dstPixels32, 0, redBlueSwap, dilateEdgesFix);
    }

    // Copy drawing surface content into the specified pixels buffer.
    public static SVGTError svgtSurfaceCopy(SVGTHandle surface, java.nio.IntBuffer dstPixels32, boolean redBlueSwap, boolean dilateEdgesFix) {

        int srfWidth, srfHeight;

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }
        if (dstPixels32 == null) {
            throw new IllegalArgumentException("dstPixels32 == null");
        }
        // get surface dimensions
        srfWidth = AmanithSVGJNI.svgtSurfaceWidth(surface.getNativeHandle());
        srfHeight = AmanithSVGJNI.svgtSurfaceHeight(surface.getNativeHandle());
        if (dstPixels32.capacity() < (srfWidth * srfHeight)) {
            throw new IllegalArgumentException("buffer capacity is not enough (dstPixels32)");
        }

        if (dstPixels32.isDirect()) {
            // the buffer is a direct buffer
            return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceCopyB(surface.getNativeHandle(), dstPixels32, boolToInt(redBlueSwap), boolToInt(dilateEdgesFix)));
        }
        else {
            // the buffer is backed by an array
            return svgtSurfaceCopy(surface, dstPixels32.array(), dstPixels32.arrayOffset(), redBlueSwap, dilateEdgesFix);
        }
    }

    // Get current destination viewport (i.e. a drawing surface rectangular area), where to map the source document viewport.
    public static SVGTError svgtSurfaceViewportGet(SVGTHandle surface, float[] viewport, int offset) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        checkArrayLength(4, viewport, offset);

        return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceViewportGet(surface.getNativeHandle(), viewport, offset));
    }

    public static SVGTError svgtSurfaceViewportGet(SVGTHandle surface, float[] viewport) {

        return svgtSurfaceViewportGet(surface, viewport, 0);
    }

    // Set destination viewport (i.e. a drawing surface rectangular area), where to map the source document viewport.
    public static SVGTError svgtSurfaceViewportSet(SVGTHandle surface, final float[] viewport, int offset) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        checkArrayLength(4, viewport, offset);
        return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceViewportSet(surface.getNativeHandle(), viewport, offset));
    }

    public static SVGTError svgtSurfaceViewportSet(SVGTHandle surface, final float[] viewport) {

        return svgtSurfaceViewportSet(surface, viewport, 0);
    }

    // Clear the whole drawing surface with the given color.
    public static SVGTError svgtSurfaceClear(SVGTHandle surface, float r, float g, float b, float a) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtSurfaceClear(surface.getNativeHandle(), r, g, b, a));
    }

    // Create and load an SVG document, specifying the whole xml string.
    public static SVGTHandle svgtDocCreate(final String xmlText) {

        int handle;

        // check arguments
        if ((xmlText == null) || (xmlText.length() < 1)) {
            throw new IllegalArgumentException("xmlText is null or empty!");
        }

        handle = AmanithSVGJNI.svgtDocCreate(xmlText);
        return (handle == AmanithSVGJNI.SVGT_INVALID_HANDLE) ? null : new SVGTHandle(handle);
    }

    // Destroy a previously created SVG document.
    public static SVGTError svgtDocDestroy(SVGTHandle svgDoc) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtDocDestroy(svgDoc.getNativeHandle()));
    }

    // Get the suggested viewport width ('width' XML attribute on the outermost <svg> element), in pixels.
    public static float svgtDocWidth(SVGTHandle svgDoc) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        return AmanithSVGJNI.svgtDocWidth(svgDoc.getNativeHandle());
    }

    public static float svgtDocHeight(SVGTHandle svgDoc) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        return AmanithSVGJNI.svgtDocHeight(svgDoc.getNativeHandle());
    }

    // Get the document (logical) viewport to map onto the destination (drawing surface) viewport.
    public static SVGTError svgtDocViewportGet(SVGTHandle svgDoc, float[] viewport, int offset) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        checkArrayLength(4, viewport, offset);
        return SVGTError.fromValue(AmanithSVGJNI.svgtDocViewportGet(svgDoc.getNativeHandle(), viewport, offset));
    }
    
    public static SVGTError svgtDocViewportGet(SVGTHandle svgDoc, float[] viewport) {

        return svgtDocViewportGet(svgDoc, viewport, 0);
    }

    // Set the document (logical) viewport to map onto the destination (drawing surface) viewport.
    public static SVGTError svgtDocViewportSet(SVGTHandle svgDoc, final float[] viewport, int offset) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        checkArrayLength(4, viewport, offset);
        return SVGTError.fromValue(AmanithSVGJNI.svgtDocViewportSet(svgDoc.getNativeHandle(), viewport, offset));
    }

    public static SVGTError svgtDocViewportSet(SVGTHandle svgDoc, final float[] viewport) {

        return svgtDocViewportSet(svgDoc, viewport, 0);
    }

    // Get the document alignment: it indicates whether to force uniform scaling and, if so, the alignment method to use.
    // Return value is [0] = SVGTAlign, [1] = SVGTMeetOrSlice
    public static int[] svgtDocViewportAlignmentGet(SVGTHandle svgDoc) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        int[] values = new int[2];
        int err = AmanithSVGJNI.svgtDocViewportAlignmentGet(svgDoc.getNativeHandle(), values, 0);
        return (err == AmanithSVGJNI.SVGT_NO_ERROR) ? values : null;
    }

    // Set the document alignment: it indicates whether to force uniform scaling and, if so, the alignment method to use.
    public static SVGTError svgtDocViewportAlignmentSet(SVGTHandle svgDoc, SVGTAlign align, SVGTMeetOrSlice meetOrSlice) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }
        if (align == null) {
            throw new IllegalArgumentException("align == null");
        }
        if (meetOrSlice == null) {
            throw new IllegalArgumentException("meetOrSlice == null");
        }

        int[] values = new int[] {
            align.getValue(),
            meetOrSlice.getValue()
        };

        return SVGTError.fromValue(AmanithSVGJNI.svgtDocViewportAlignmentSet(svgDoc.getNativeHandle(), values, 0));
    }

    // Draw an SVG document, on the specified drawing surface, with the given rendering quality.
    public static SVGTError svgtDocDraw(SVGTHandle svgDoc, SVGTHandle surface, SVGTRenderingQuality renderingQuality) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtDocDraw(svgDoc.getNativeHandle(), surface.getNativeHandle(), renderingQuality.getValue()));
    }

    // Map a point, expressed in the document viewport system, into the surface viewport.
    public static SVGTError svgtPointMap(SVGTHandle svgDoc, SVGTHandle surface, float x, float y, float[] dst, int offset) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        checkArrayLength(2, dst, offset);
        return SVGTError.fromValue(AmanithSVGJNI.svgtPointMap(svgDoc.getNativeHandle(), surface.getNativeHandle(), x, y, dst, offset));
    }

    public static SVGTError svgtPointMap(SVGTHandle svgDoc, SVGTHandle surface, float x, float y, float[] dst) {

        return svgtPointMap(svgDoc, surface, x, y, dst, 0);
    }

    // Start a packing task: one or more SVG documents will be collected and packed into bins, for the generation of atlases.
    public static SVGTError svgtPackingBegin(int maxDimension, int border, boolean pow2Bins, float scale) {

        // native svgtPackingBegin takes unsigned integers as dimension and border, JNI wrapper simply
        // casts them to unsigned integer so here we have to "protect" the native cast operation
        if (maxDimension < 0) {
            throw new IllegalArgumentException("maxDimension < 0");
        }
        if (border < 0) {
            throw new IllegalArgumentException("border < 0");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtPackingBegin(maxDimension, border, boolToInt(pow2Bins), scale));
    }

    // Add an SVG document to the current packing task.
    public static SVGTError svgtPackingAdd(SVGTHandle svgDoc, boolean explodeGroups, float scale, int[] info, int offset) {

        // check arguments
        if (svgDoc == null) {
            throw new IllegalArgumentException("svgDoc == null");
        }

        checkArrayLength(2, info, offset);
        return SVGTError.fromValue(AmanithSVGJNI.svgtPackingAdd(svgDoc.getNativeHandle(), boolToInt(explodeGroups), scale, info, offset));
    }

    public static SVGTError svgtPackingAdd(SVGTHandle svgDoc, boolean explodeGroups, float scale, int[] info) {

        return svgtPackingAdd(svgDoc, explodeGroups, scale, info, 0);
    }

    // Close the current packing task and, if specified, perform the real packing algorithm.
    public static SVGTError svgtPackingEnd(boolean performPacking) {

        return SVGTError.fromValue(AmanithSVGJNI.svgtPackingEnd(boolToInt(performPacking)));
    }

    // Return the number of generated bins from the last packing task.
    public static int svgtPackingBinsCount() {

        return AmanithSVGJNI.svgtPackingBinsCount();
    }

    // Return information about the specified bin.
    public static SVGTError svgtPackingBinInfo(int binIdx, int[] binInfo, int offset) {

        // native svgtPackingBinInfo takes unsigned integer as binIdx, JNI wrapper simply casts
        // them to unsigned integer so here we have to "protect" the native cast operation
        if (binIdx < 0) {
            throw new IllegalArgumentException("binIdx < 0");
        }

        // check arguments
        checkArrayLength(3, binInfo, offset);
        return SVGTError.fromValue(AmanithSVGJNI.svgtPackingBinInfo(binIdx, binInfo, offset));
    }

    public static SVGTError svgtPackingBinInfo(int binIdx, int[] binInfo) {

        return svgtPackingBinInfo(binIdx, binInfo, 0);
    }

    // Get access to packed rectangles, relative to a specified bin.
    public static java.nio.ByteBuffer svgtPackingBinRects(int binIdx) {

        // native svgtPackingBinRects takes unsigned integer as binIdx, JNI wrapper simply casts
        // them to unsigned integer so here we have to "protect" the native cast operation
        if (binIdx < 0) {
            throw new IllegalArgumentException("binIdx < 0");
        }

        return AmanithSVGJNI.svgtPackingBinRects(binIdx);
    }

    // Draw a set of packed SVG documents/elements over the specified drawing surface.
    public static SVGTError svgtPackingDraw(int binIdx, int startRectIdx, int rectsCount, SVGTHandle surface, SVGTRenderingQuality renderingQuality) {

        // check arguments
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }
        // native svgtPackingDraw takes unsigned integers as binIdx, startRectIdx and rectsCount, JNI wrapper
        // simply casts them to unsigned integer so here we have to "protect" the native cast operation
        if (binIdx < 0) {
            throw new IllegalArgumentException("binIdx < 0");
        }
        if (startRectIdx < 0) {
            throw new IllegalArgumentException("startRectIdx < 0");
        }
        if (rectsCount < 0) {
            throw new IllegalArgumentException("rectsCount < 0");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtPackingDraw(binIdx, startRectIdx, rectsCount, surface.getNativeHandle(), renderingQuality.getValue()));
    }

    public static SVGTError svgtPackingRectsDraw(java.nio.ByteBuffer rects, SVGTHandle surface, SVGTRenderingQuality renderingQuality) {

        // check arguments
        if (rects == null) {
            throw new IllegalArgumentException("rects == null");
        }
        if (!rects.isDirect()) {
            throw new IllegalArgumentException("rects must be a direct buffer");   
        }
        if (surface == null) {
            throw new IllegalArgumentException("surface == null");
        }

        return SVGTError.fromValue(AmanithSVGJNI.svgtPackingRectsDraw(rects, surface.getNativeHandle(), renderingQuality.getValue()));
    }

    // Get renderer and version information.
    public static String svgtGetString(SVGTStringID name) {

        // check arguments
        if (name == null) {
            throw new IllegalArgumentException("name == null");
        }

        return AmanithSVGJNI.svgtGetString(name.getValue());
    }

    //------------------------------------------------------------------------------------------
    //                        Misc utilities for JAVA/JNI interworking
    //------------------------------------------------------------------------------------------
    public static int svgtPackedRectSize() {

        return AmanithSVGJNI.svgtPackedRectSize();
    }

    public static String svgtPackedRectName(long namePtr) {

        return (namePtr != 0) ? AmanithSVGJNI.svgtPackedRectName(namePtr) : "";
    }
}
